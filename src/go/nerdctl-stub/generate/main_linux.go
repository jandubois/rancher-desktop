// package main produces stubs for the nerdctl subcommands (and their
// options); this is expected to be overridden for options that involve paths.
// All options generated this will have their values ignored.
package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"runtime"
	"runtime/debug"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"github.com/sirupsen/logrus"
)

// nerdctl contains the path to the nerdctl binary to run.
var nerdctl = "/usr/local/bin/nerdctl"

// outputPath is the file we should generate.
var outputPath = "../nerdctl_commands_generated.go"

type helpData struct {
	// Commands lists the subcommands available
	Commands []string
	// options available for this command; the key is the long option
	// (`--version`) or the short option (`-v`), and the value is whether the
	// option takes an argument.
	Options map[string]bool
	// If set, this command can have subcommands; this alters argument parsing.
	canHaveSubcommands bool
	// If set, this command can pass flags to foreign commands, as in `nerdctl run`.
	// This alters argument parsing by letting us ignore unknown flags.
	HasForeignFlags bool
	// mergedOptions includes local options plus inherited options.
	mergedOptions map[string]struct{}
}

// prologueTemplate describes the file header for the generated file.
const prologueTemplate = `
// Code generated by {{ .package }} - DO NOT EDIT.

// package main implements a stub for nerdctl
package main

// commands supported by nerdctl; the key here is a space-separated subcommand
// path to reach the given subcommand (where the root command is empty).
var commands = map[string]commandDefinition {
`

// epilogueTemplate describes the file trailer for the generated file.
const epilogueTemplate = `
}
`

func main() {
	verbose := flag.Bool("verbose", false, "extra logging")
	flag.Parse()
	if *verbose {
		logrus.SetLevel(logrus.TraceLevel)
	}

	output, err := os.Create(outputPath)
	if err != nil {
		logrus.WithError(err).WithField("path", outputPath).Fatal("error creating output")
	}
	defer output.Close()
	//nolint:dogsled // we only require the file name; we can also ignore `ok`, as
	// on failure we just have no useful file name.
	_, filename, _, _ := runtime.Caller(0)
	data := map[string]interface{}{
		"package": filename,
	}
	if buildInfo, ok := debug.ReadBuildInfo(); ok {
		data["package"] = buildInfo.Main.Path
	}
	err = template.Must(template.New("").Parse(prologueTemplate)).Execute(output, data)
	if err != nil {
		logrus.WithError(err).Fatal("could not execute prologue")
	}
	err = buildSubcommand(context.Background(), []string{}, helpData{}, output)
	if err != nil {
		logrus.WithError(err).Fatal("could not build subcommands")
	}
	err = template.Must(template.New("").Parse(epilogueTemplate)).Execute(output, data)
	if err != nil {
		logrus.WithError(err).Fatal("could not execute epilogue")
	}
}

// buildSubcommand generates the option parser data for a given subcommand.
// args provides the list of arguments to get to the subcommand; the last
// element in the slice is the name of the subcommand.
// writer is the file to write to for the result; it is expected that `go fmt`
// will be run on it eventually.
func buildSubcommand(ctx context.Context, args []string, parentData helpData, writer io.Writer) error {
	help, err := getHelp(ctx, args)
	if err != nil {
		return fmt.Errorf("error getting help for %v: %w", args, err)
	}
	subcommands := parseHelp(help, parentData)

	fields := logrus.Fields{"args": args}
	if subcommands.HasForeignFlags {
		fields["type"] = "arguments"
	} else if !subcommands.canHaveSubcommands {
		fields["type"] = "positional"
	}
	logrus.WithFields(fields).Trace("building subcommand")

	if !subcommands.canHaveSubcommands && len(subcommands.Commands) > 0 {
		return fmt.Errorf("invalid command %v: has positional arguments, but also subcommands %+v", args, subcommands.Commands)
	}
	if subcommands.canHaveSubcommands && subcommands.HasForeignFlags {
		return fmt.Errorf("invalid command %v: has subcommands and foreign flags", args)
	}

	err = emitCommand(args, subcommands, writer)
	if err != nil {
		return err
	}

	for _, subcommand := range subcommands.Commands {
		newArgs := make([]string, 0, len(args))
		newArgs = append(newArgs, args...)
		newArgs = append(newArgs, subcommand)
		err := buildSubcommand(ctx, newArgs, subcommands, writer)
		if err != nil {
			return err
		}
	}

	return nil
}

// getHelp runs `nerdctl <args...> -help` and returns the result.
func getHelp(ctx context.Context, args []string) (string, error) {
	newArgs := make([]string, 0, len(args)+1)
	newArgs = append(newArgs, args...)
	newArgs = append(newArgs, "--help")
	cmd := exec.CommandContext(ctx, nerdctl, newArgs...)
	cmd.Stderr = os.Stderr
	result, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return string(result), nil
}

const (
	STATE_OTHER = iota
	STATE_COMMANDS
	STATE_OPTIONS
)

// parseHelp consumes the output of `nerdctl help` (possibly for a subcommand)
// and returns the available subcommands and options.
func parseHelp(help string, parentData helpData) helpData {
	result := helpData{Options: make(map[string]bool), mergedOptions: make(map[string]struct{})}
	for k := range parentData.mergedOptions {
		result.mergedOptions[k] = struct{}{}
	}
	state := STATE_OTHER
	for _, line := range strings.Split(help, "\n") {
		line = strings.TrimRightFunc(line, unicode.IsSpace)
		if line == "" {
			// Skip empty lines (don't switch state either)
			continue
		}
		if !strings.HasPrefix(line, " ") {
			// Line does not start with a space; it's a section header.
			if strings.HasSuffix(strings.ToUpper(line), "COMMANDS:") {
				state = STATE_COMMANDS
			} else if strings.HasSuffix(strings.ToUpper(line), "FLAGS:") {
				state = STATE_OPTIONS
			} else if strings.HasPrefix(strings.ToUpper(line), "USAGE:") {
				// Usage is on the same line, so we have to process this now.
				// Command is `nerdctl subcommand [flags]`; anything after `[flags]` is
				// assumed to be positional arguments.
				_, newArgs, _ := strings.Cut(strings.ToUpper(line), "[FLAGS]")
				newArgs = strings.TrimSpace(newArgs)
				// Unlike everything else, `nerdctl compose` has a usage string of
				// `nerdctl compose [flags] COMMAND` so we need to ignore that.
				if newArgs == "" || newArgs == "COMMAND" {
					result.canHaveSubcommands = true
				} else if strings.Contains(newArgs, "COMMAND") && strings.Contains(newArgs, "...") {
					result.HasForeignFlags = true
				}
			} else {
				state = STATE_OTHER
			}
			continue
		}
		line = strings.TrimLeftFunc(line, unicode.IsSpace)
		if state == STATE_COMMANDS {
			parts := strings.SplitN(line, "  ", 2)
			if len(parts) < 2 {
				// This line does not contain a command.
				continue
			}
			words := strings.Split(strings.TrimSpace(parts[0]), ", ")
			result.Commands = append(result.Commands, words...)
		} else if state == STATE_OPTIONS {
			parts := strings.SplitN(line, "  ", 2)
			if len(parts) < 2 {
				// This line does not contain an option.
				continue
			}
			// The flags help has the format: `-f, --foo string   Description`
			// In order to figure out if the option takes arguments, we need to
			// parse the whole line first.
			var words []string
			hasOptions := false
			for _, word := range strings.Split(strings.TrimSpace(parts[0]), ", ") {
				spaceIndex := strings.Index(word, " ")
				if spaceIndex > -1 {
					hasOptions = true
					word = word[:spaceIndex]
				}
				words = append(words, word)
			}
			// We may find an inherited flag; skip if the long option exists in
			// the parent
			if len(words) < 1 {
				continue
			}
			if _, ok := parentData.mergedOptions[words[len(words)-1]]; !ok {
				for _, word := range words {
					result.Options[word] = hasOptions
					result.mergedOptions[word] = struct{}{}
				}
			}
		}
	}
	sort.Strings(result.Commands)
	return result
}

// commandTemplate is the text/template template for a single subcommand.
const commandTemplate = `
	{{ printf "%q" .Args }}: {
		commandPath: {{ printf "%q" .Args }},
		subcommands: map[string]struct{} {
			{{- range .Data.Commands }}
				{{ printf "%q" . }}: {},
			{{- end }}
		},
		options: map[string]argHandler {
			{{ range $k, $v := .Data.Options }}
				{{- printf "%q" $k -}}: {{ if $v -}} ignoredArgHandler {{- else -}} nil {{- end -}},
			{{ end }}
		},
		{{- if .Data.HasForeignFlags }}
			hasForeignFlags: true,
		{{- end }}
	},
`

// commandTemplateInput describes the data that will be fed to commandTemplate.
type commandTemplateInput struct {
	Args string
	Data helpData
}

// emitCommand outputs the golang code to the given writer.  args indicates the
// arguments to reach this subcommand, and data is the parsed help output.
func emitCommand(args []string, data helpData, writer io.Writer) error {
	templateData := commandTemplateInput{
		Args: strings.Join(args, " "),
		Data: data,
	}

	tmpl := template.Must(template.New("").Parse(commandTemplate))
	err := tmpl.Execute(writer, templateData)
	if err != nil {
		return err
	}
	return nil
}
